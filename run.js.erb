const tour = new Shepherd.Tour({
  useModalOverlay: true,
  defaultStepOptions: {
    scrollTo: false,
    cancelIcon: {
      enabled: true
    }
  }
});

<% total_steps = tutorial.tutorial_steps.length -%>
<% tutorial.tutorial_steps.order(:position).each_with_index do |step, index| -%>
tour.addStep({
  id: `<%= step.name %>`,
  title: `<%= step.title %>`,
  text: `<%= md_render step.text %>`,
  <% if step.element.present? %>
  attachTo: {
    element: `<%=raw step.element %>`,
    on: `<%= step.location %>`
  },
  <% end %>
  <% if step.wait_element.present? %>
  when: {
    show: () => waitForElement('<%= j step.wait_element %>')
  },
  <% end %>

  buttons: [
    <% if index > 0 -%>
    { text: 'Back', action: tour.back },
    <% end -%>
    <% if index < total_steps - 1 -%>
    {
      text: 'Next',
      action: function () {
        <% if step.element_type == 'dropdown' %>
        const dropdown = document.querySelector('<%= j step.element %>');
        if (dropdown && dropdown.options[dropdown.selectedIndex].text.trim() === '<%= j step.additional_element %>') {
            tour.next();
        } else {
            alert('<%= j step.alert_message %>');
        }
        <% elsif step.element_type == 'button' %>
        const button = document.querySelector('<%= j step.element %>');
        if (button && button.clicked) {
            tour.next();
        } else {
            alert('<%= j step.alert_message %>');
        }
        <% elsif step.element_type == 'radio' %>
        const radio = document.querySelector('<%= j step.additional_element %>');
        if (radio && radio.checked) {
            tour.next();
        } else {
            alert('<%= j step.alert_message %>');
        }
        <% elsif step.element_type == 'text' %>
        const input = document.querySelector('<%= j step.element %>');
        if (input && input.value.trim() === '<%= j step.additional_element %>') {
            tour.next();
        } else {
            alert('<%= j step.alert_message %>');
        }
        <% else %>
            tour.next();
        <% end %>
        }
      }
    }
    <% else -%>
    { text: 'Finish', action: tour.complete }
    <% end -%>
  ],
    <% if ['dropdown', 'radio'].include?(step.element_type) %>
  when: {
    show: () => {
      const el = document.querySelector('<%= j step.element %>');
      if (!el) return;

      <% if step.element_type == 'dropdown' %>
      const handler = () => {
        if (el.options[el.selectedIndex].text.trim() === '<%= j step.additional_element %>') {
          el.removeEventListener('change', handler);
          setTimeout(() => {
            if (tour.getCurrentStep().id === '<%= step.name %>') tour.next();
          }, 500);
        }
      };
      el.addEventListener('change', handler);
      <% elsif step.element_type == 'radio' %>
      const radio = document.querySelector('<%= j step.additional_element %>');
      if (radio) {
        const handler = () => {
          if (radio.checked) {
            radio.removeEventListener('change', handler);
            setTimeout(() => {
              if (tour.getCurrentStep().id === '<%= step.name %>') tour.next();
            }, 500);
          }
        };
        radio.addEventListener('change', handler);
      }
      <% end %>
    }
  }
  <% end %>
});

<% end -%>

<%# Handle delayed start if first step has a wait_element defined %>
<% first_step = tutorial.tutorial_steps.order(:position).first -%>
<% if first_step.wait_element.present? -%>
waitForElement('<%= j first_step.wait_element %>')
  .then(() => {
    tour.start();
  });
<% else -%>
tour.start();
<% end -%>

function waitForElement(selector, timeout = 15000) {
  return new Promise((resolve, reject) => {
    const interval = 100;
    let waited = 0;

    const check = setInterval(() => {
      const el = document.querySelector(selector);
      if (el) {
        clearInterval(check);
        resolve(el);
      } else if (waited >= timeout) {
        clearInterval(check);
        reject(new Error(`Element "${selector}" not found within ${timeout}ms`));
      }
      waited += interval;
    }, interval);
  });
}

